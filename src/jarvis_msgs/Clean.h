// Generated by gencpp from file jarvis_msgs/Clean.msg
// DO NOT EDIT!


#ifndef JARVIS_MSGS_MESSAGE_CLEAN_H
#define JARVIS_MSGS_MESSAGE_CLEAN_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace jarvis_msgs
{
template <class ContainerAllocator>
struct Clean_
{
  typedef Clean_<ContainerAllocator> Type;

  Clean_()
    : water_inject(0)
    , brush_height(0)
    , brush_speed(0)
    , squeeegee_dust_mop_up(0)
    , water_spray_level(0)
    , scution_level(0)
    , disinfection_spray_on(0)
    , spray_volume(0)
    , spray_distance(0)
    , automatic_liquid_filling(0)  {
    }
  Clean_(const ContainerAllocator& _alloc)
    : water_inject(0)
    , brush_height(0)
    , brush_speed(0)
    , squeeegee_dust_mop_up(0)
    , water_spray_level(0)
    , scution_level(0)
    , disinfection_spray_on(0)
    , spray_volume(0)
    , spray_distance(0)
    , automatic_liquid_filling(0)  {
  (void)_alloc;
    }



   typedef int8_t _water_inject_type;
  _water_inject_type water_inject;

   typedef int8_t _brush_height_type;
  _brush_height_type brush_height;

   typedef int8_t _brush_speed_type;
  _brush_speed_type brush_speed;

   typedef int8_t _squeeegee_dust_mop_up_type;
  _squeeegee_dust_mop_up_type squeeegee_dust_mop_up;

   typedef int8_t _water_spray_level_type;
  _water_spray_level_type water_spray_level;

   typedef int8_t _scution_level_type;
  _scution_level_type scution_level;

   typedef int8_t _disinfection_spray_on_type;
  _disinfection_spray_on_type disinfection_spray_on;

   typedef int8_t _spray_volume_type;
  _spray_volume_type spray_volume;

   typedef int8_t _spray_distance_type;
  _spray_distance_type spray_distance;

   typedef int8_t _automatic_liquid_filling_type;
  _automatic_liquid_filling_type automatic_liquid_filling;





  typedef boost::shared_ptr< ::jarvis_msgs::Clean_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::jarvis_msgs::Clean_<ContainerAllocator> const> ConstPtr;

}; // struct Clean_

typedef ::jarvis_msgs::Clean_<std::allocator<void> > Clean;

typedef boost::shared_ptr< ::jarvis_msgs::Clean > CleanPtr;
typedef boost::shared_ptr< ::jarvis_msgs::Clean const> CleanConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::jarvis_msgs::Clean_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::jarvis_msgs::Clean_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::jarvis_msgs::Clean_<ContainerAllocator1> & lhs, const ::jarvis_msgs::Clean_<ContainerAllocator2> & rhs)
{
  return lhs.water_inject == rhs.water_inject &&
    lhs.brush_height == rhs.brush_height &&
    lhs.brush_speed == rhs.brush_speed &&
    lhs.squeeegee_dust_mop_up == rhs.squeeegee_dust_mop_up &&
    lhs.water_spray_level == rhs.water_spray_level &&
    lhs.scution_level == rhs.scution_level &&
    lhs.disinfection_spray_on == rhs.disinfection_spray_on &&
    lhs.spray_volume == rhs.spray_volume &&
    lhs.spray_distance == rhs.spray_distance &&
    lhs.automatic_liquid_filling == rhs.automatic_liquid_filling;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::jarvis_msgs::Clean_<ContainerAllocator1> & lhs, const ::jarvis_msgs::Clean_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace jarvis_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::jarvis_msgs::Clean_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::jarvis_msgs::Clean_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::jarvis_msgs::Clean_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::jarvis_msgs::Clean_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::jarvis_msgs::Clean_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::jarvis_msgs::Clean_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::jarvis_msgs::Clean_<ContainerAllocator> >
{
  static const char* value()
  {
    return "7885452e7570601f23959814714fcacf";
  }

  static const char* value(const ::jarvis_msgs::Clean_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x7885452e7570601fULL;
  static const uint64_t static_value2 = 0x23959814714fcacfULL;
};

template<class ContainerAllocator>
struct DataType< ::jarvis_msgs::Clean_<ContainerAllocator> >
{
  static const char* value()
  {
    return "jarvis_msgs/Clean";
  }

  static const char* value(const ::jarvis_msgs::Clean_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::jarvis_msgs::Clean_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int8 water_inject\n"
"int8 brush_height\n"
"int8 brush_speed\n"
"int8 squeeegee_dust_mop_up\n"
"int8 water_spray_level\n"
"int8 scution_level\n"
"int8 disinfection_spray_on\n"
"int8 spray_volume\n"
"int8 spray_distance\n"
"int8 automatic_liquid_filling\n"
;
  }

  static const char* value(const ::jarvis_msgs::Clean_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::jarvis_msgs::Clean_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.water_inject);
      stream.next(m.brush_height);
      stream.next(m.brush_speed);
      stream.next(m.squeeegee_dust_mop_up);
      stream.next(m.water_spray_level);
      stream.next(m.scution_level);
      stream.next(m.disinfection_spray_on);
      stream.next(m.spray_volume);
      stream.next(m.spray_distance);
      stream.next(m.automatic_liquid_filling);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Clean_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::jarvis_msgs::Clean_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::jarvis_msgs::Clean_<ContainerAllocator>& v)
  {
    s << indent << "water_inject: ";
    Printer<int8_t>::stream(s, indent + "  ", v.water_inject);
    s << indent << "brush_height: ";
    Printer<int8_t>::stream(s, indent + "  ", v.brush_height);
    s << indent << "brush_speed: ";
    Printer<int8_t>::stream(s, indent + "  ", v.brush_speed);
    s << indent << "squeeegee_dust_mop_up: ";
    Printer<int8_t>::stream(s, indent + "  ", v.squeeegee_dust_mop_up);
    s << indent << "water_spray_level: ";
    Printer<int8_t>::stream(s, indent + "  ", v.water_spray_level);
    s << indent << "scution_level: ";
    Printer<int8_t>::stream(s, indent + "  ", v.scution_level);
    s << indent << "disinfection_spray_on: ";
    Printer<int8_t>::stream(s, indent + "  ", v.disinfection_spray_on);
    s << indent << "spray_volume: ";
    Printer<int8_t>::stream(s, indent + "  ", v.spray_volume);
    s << indent << "spray_distance: ";
    Printer<int8_t>::stream(s, indent + "  ", v.spray_distance);
    s << indent << "automatic_liquid_filling: ";
    Printer<int8_t>::stream(s, indent + "  ", v.automatic_liquid_filling);
  }
};

} // namespace message_operations
} // namespace ros

#endif // JARVIS_MSGS_MESSAGE_CLEAN_H
